
module Descent.TH where

import Data.Traversable
import Data.Functor ((<&>))
import Data.Set qualified as Set

import Language.Haskell.TH

-- import Debug.Trace

data DescentConfig = DescentConfig
  { recure :: [Name]
  , visit  :: [Name]
  }

generateDescentInstances :: DescentConfig -> Q [Dec]
generateDescentInstances DescentConfig { recure, visit } = do
  for recure \root -> do
    Just descent <- lookupTypeName "Descent"
    info <- reify root
    case info of
      TyConI (DataD _ _tvars _ _ cons _) -> do
        matches <- for cons \con -> ctors root con
        return
          $ InstanceD Nothing [] (AppT (ConT descent) (ConT root))
          [ FunD (mkName "descend")
            [Clause [arg "_leaf", arg "_branch"] (NormalB (LamCaseE (concat matches))) []]
          ]
      i -> fail $ "It is only possible to descend over an ADT type, but not over `" ++ show (ppr i) ++ "`"
  where
    recureSet = Set.fromList recure
    visitSet  = Set.fromList visit

    arg = VarP . mkName
    var = VarE . mkName

    ctors :: Name -> Con -> Q [Match]
    ctors n = \case
      NormalC  ctorName  args   -> pure <$> matcher n ctorName [ty | (_, ty) <- args]
      RecC     ctorName  args   -> pure <$> matcher n ctorName [ty | (_, _, ty) <- args]
      GadtC    ctorNames args _ -> for ctorNames \ctorName -> matcher n ctorName [ty | (_, ty) <- args]
      RecGadtC ctorNames args _ -> for ctorNames \ctorName -> matcher n ctorName [ty | (_, _, ty) <- args]
      InfixC (_, l) ctorName (_, r) -> pure <$> matcher n ctorName [l, r]
      c                             -> fail $ "We can't into foralls yet :( " ++ show c

    matcher :: Name -> Name -> [Type] -> Q Match
    matcher root ctor args = Match pat <$> body <*> pure []
      where
        pat :: Pat
        pat = ConP ctor [VarP var' | (var', _) <- vars]

        body :: Q Body
        body = do
          visitors <- for vars visitor'
          return
            $ NormalB
            $ UInfixE (ConE ctor) (var "<$>")
            $ foldl1 (\a b -> UInfixE a (var "<*>") b) visitors

        visitor' :: (Name, Type) -> Q Exp
        visitor' (n, ty) = visitor ty ty <&> (`AppE` VarE n)

        visitor :: Type -> Type -> Q Exp
        visitor _ (ConT ty)
          | ty `Set.member` recureSet = return $ var "_branch"
          | ty `Set.member` visitSet  = return $ var "_leaf"
          | otherwise                 = return $ var "pure"

        visitor src (AppT _ x) = (var "traverse" `AppE`) <$> visitor src x
        visitor src (AppKindT t _) = visitor src t
        visitor src ty
          = fail
          $  "The descend can only be autogenerated for plain types and `Traversable` wrappers. "
          ++ "This type is neither of them: `" ++ show (ppr ty)
          ++ "` in type expression `"          ++ show (ppr src)
          ++ "` in constructor `"              ++ show (ppr ctor)
          ++ "` from type `"                   ++ show (ppr root)
          ++ "`."

        vars = zip ([mkName ("a" ++ show i) | i <- [0 :: Int ..]]) args
